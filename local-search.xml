<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/17/hello-world/"/>
    <url>/2024/07/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>快速上手TS（进阶篇）</title>
    <link href="/2023/07/10/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BTS/"/>
    <url>/2023/07/10/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BTS/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c92154b7fc1549e98c18ac66b04f5410~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1082&h=453&s=606549&e=png&b=030303" alt="image.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://juejin.cn/post/7383643463532953619">快速上手 TS（环境篇）- 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7386701961808904204">快速上手 TS（基础类型篇）- 掘金 (juejin.cn)</a></li></ul><p>前两篇中我介绍了 TS 从安装到运行的环境配置，以及 TS 的基础类型介绍，希望能够对你带来帮助。今天我们来学习一下 TS 的进阶知识，数组、元组、函数、接口等等，具体可以参考目录，还是那句话希望我能坚持更新，更希望你能坚持看下去！</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在 JS 中数组就是数组，但 TS 中的数组被分为了数组和元组</p><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><p>TS 数组有一个根本的特征，所有的成员类型必须相同，成员数量可以不确定。</p><p>数组有两种声明方式，类型后面加<code>[]</code>或者使用内置<code>Array</code>接口（下面会详细介绍接口 interface）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>如果成员类型有不同类型，可以使用联合类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;阳阳羊&quot;</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;阳阳羊&quot;</span>];<br></code></pre></td></tr></table></figure><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>数组的类型推断与前文讲的有所不同，它会根据每个成员的类型而变化</p><p>如果没有声明数组类型，TS 会自动进行类型推断，当数组为空时，会推断为<code>any</code>类型的数组</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89c40b0e3b3c48e1ba5fb62597e78793~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=295&h=86&s=4591&e=png&b=1f1f1f" alt="image.png" width="30%" /><p>当我们修改成员时，会自动进行更新。</p><p>这里我们<code>push</code>一个数字，会自动推断为<code>number</code>数组</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e381d85cb3742d282c8e2c8385aac75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=302&h=143&s=7453&e=png&b=1f1f1f" alt="image.png" width="30%" /><p>我们再<code>push</code>一个字符串，自动推断成联合类型<code>string | number</code>的数组</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed3af34f1a943718984afa42f7d5525~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=405&h=164&s=11903&e=png&b=1e1e1e" alt="image.png" width="50%" /><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组是 TS 新增的数据类型，它表示成员类型可以自由设置的数组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>] = [<span class="hljs-string">&quot;阳阳羊&quot;</span>, <span class="hljs-number">123</span>, <span class="hljs-literal">true</span>];<br></code></pre></td></tr></table></figure><p>写法上与数组有所不同，数组的类型是写在<code>[]</code>的左边，而元组的类型是写在<code>[]</code>内部。</p><p>使用元组时必须给出类型声明，不然会被 TS 自动推断为数组</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3c5599c3b04805a490f0d506373b24~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=578&h=87&s=9894&e=png&b=1f1f1f" alt="image.png" width="50%" /><h4 id="可选符"><a href="#可选符" class="headerlink" title="?可选符"></a><code>?</code>可选符</h4><p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>?] = [<span class="hljs-string">&quot;阳阳羊&quot;</span>, <span class="hljs-number">123</span>];<br></code></pre></td></tr></table></figure><p>需要注意的是可选成员要放在尾部，即所有可选成员必须在必选成员之后</p><p>如果放在前面会报错</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a91064aa2774f42ab530ec2ef5cee14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&h=150&s=22684&e=png&b=1f1f1f" alt="image.png" width="70%" /><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="...扩展运算符"></a><code>...</code>扩展运算符</h4><p>一般情况下，元组的成员数量是固定的，有多少个类型声明就有多少个成员，但是<code>...</code>扩展运算符允许我们表示不定成员数量的元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, ...<span class="hljs-built_in">number</span>[]] = [<span class="hljs-string">&quot;阳阳羊&quot;</span>, <span class="hljs-number">123</span>, <span class="hljs-number">456</span>];<br></code></pre></td></tr></table></figure><p>扩展运算符用在元组的任意位置都可以，但是只能扩展数组或元组。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的类型声明，需要给出参数和返回值的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里两个参数<code>a</code>、<code>b</code>类型都为<code>number</code>，以及返回值的类型<code>number</code>，返回值类型写在参数列表的圆括号后面。</p><p>我们也可以使用函数表达式进行声明</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的两种方式都可以实现，第一种是通过等号右边来推断<code>fn</code>的类型，第二种则是直接指明了<code>fn</code>的类型。</p><p>返回值类型通常可以不写，TS 会自己推断出来，如果没写<code>return</code>语句，会推断为没有返回值</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54abea603554da3a2b998bbf727de04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=494&h=138&s=13079&e=png&b=1f1f1f" alt="image.png" width="50%" /><h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>void 类型表示函数没有返回值。如果你学过 c 语言，那你一定不会陌生。</p><p>在 TS 中<code>void</code>并不代表不能写<code>return</code>语句，它允许返回<code>undefined</code>或<code>null</code>（<code>null</code>需要关闭严格模式），因为它俩在 TS 看来也是相当于没有返回值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果你返回其它类型就会报错</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">return</span> a + b; <span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76765d6f43fc4fabb8edf79d0ebc8efa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=569&h=162&s=18617&e=png&b=272728" alt="image.png" width="70%" /><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载。</p><p>这里我们想实现一个函数，不管你传入的是数组还是字符串，我都希望它返回一个反转后的结果</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">reverse</span>(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// &#x27;cba&#x27;</span><br><span class="hljs-title function_">reverse</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure><p>首先我们逐一定义每一种情况的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params"><span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">any</span>[]</span>): <span class="hljs-built_in">any</span>[];<br></code></pre></td></tr></table></figure><p>然后给予函数完整的类型声明</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params"><span class="hljs-attr">stringOrArray</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">any</span>[]</span>): <span class="hljs-built_in">string</span> | <span class="hljs-built_in">any</span>[] &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> stringOrArray === <span class="hljs-string">&quot;string&quot;</span>)<br>    <span class="hljs-keyword">return</span> stringOrArray.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> stringOrArray.<span class="hljs-title function_">slice</span>().<span class="hljs-title function_">reverse</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverse</span>([<span class="hljs-string">&quot;🐂&quot;</span>, <span class="hljs-string">&quot;🐑&quot;</span>, <span class="hljs-string">&quot;🐎&quot;</span>, <span class="hljs-string">&quot;🐒&quot;</span>])); <span class="hljs-comment">//[ &#x27;🐒&#x27;, &#x27;🐎&#x27;, &#x27;🐑&#x27;, &#x27;🐂&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverse</span>(<span class="hljs-string">&quot;牛羊马猴&quot;</span>)); <span class="hljs-comment">//猴马羊牛</span><br></code></pre></td></tr></table></figure><h2 id="type-命令"><a href="#type-命令" class="headerlink" title="type 命令"></a>type 命令</h2><p>TS 允许我们用 type 来定义一个类型别名，我们习惯使用大驼峰命名方式进行命名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-title class_">Name</span> = <span class="hljs-string">&quot;阳阳羊&quot;</span>;<br></code></pre></td></tr></table></figure><p>这样<code>Age</code>就能像使用<code>number</code>一样作为类型来使用</p><p>别名不允许重名，拿值类型来举例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = <span class="hljs-string">&quot;红&quot;</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = <span class="hljs-string">&quot;绿&quot;</span>; <span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><p>如果一些类型定义很冗长，我们往往会用 type 命令为函数类型定义一个别名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyFunc</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">fn</span>: <span class="hljs-title class_">MyFunc</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello &quot;</span> + a);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface 接口"></a>interface 接口</h2><p>interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们定义了一个接口<code>Person</code>，两个属性<code>name</code>和<code>age</code>，任何实现这个接口的对象都必须具有这两个属性，并符合规定类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">me</span>: <span class="hljs-title class_">Person</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;阳阳羊&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果属性和类型有一个不符就会报错。</p><p>如果你希望属性是可选的，则可以使用<code>?</code>可选操作符，只读可以使用<code>readonly</code>修饰符</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  name?: <span class="hljs-string">&quot;阳阳羊&quot;</span>;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>除了属性外，接口还允许我们定义对象的方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">say</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>接口也可以用来声明独立的函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Add</span> &#123;<br>  (<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">myAdd</span>: <span class="hljs-title class_">Add</span> = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;<br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>接口可以使用<code>extends</code>关键字实现继承</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>extends</code>关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性</p><p>如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。前提是不能有冲突，属性方法他们的类型得是一致的，不然会报错</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">bigint</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里存在同名属性，但是类型不一致</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3634c66ca59942e287f2cde4ae39687c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=519&h=226&s=30080&e=png&b=272728" alt="image.png"></p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>多个同名接口会合并成一个接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span> &#123;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span> &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个<code>Box</code>接口会合并成一个接口，同时有<code>height</code>、<code>width</code>和<code>length</code>三个属性。前提仍然是不能有冲突。</p><h3 id="和-type-的区别"><a href="#和-type-的区别" class="headerlink" title="和 type 的区别"></a>和 type 的区别</h3><p>（1）<code>type</code>能够表示非对象类型，而<code>interface</code>只能表示对象类型（包括数组、函数等）。</p><p>（2）<code>interface</code>可以继承其他类型，<code>type</code>不支持继承。</p><p>（3）同名<code>interface</code>会自动合并，同名<code>type</code>则会报错。也就是说，TypeScript 不允许使用<code>type</code>多次定义同一个类型。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://typescript.p6p.net/typescript-tutorial/types.html">阮一峰 TypeScript 教程</a></li><li><a href="https://www.typescriptlang.org/">TypeScript 官方文档</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上是对 TS 进阶类型的基本介绍，内容相对于基础，对于新同学来说比较友好，后面我会继续更新进阶知识，关于类、泛型、Enum 类型等等，可以收藏本站，我会持续更新。</p><p>已将学习代码上传至 <a href="https://github.com/YangyangU/CodeSpace">github</a>，欢迎大家学习指正！</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
